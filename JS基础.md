[TOC]



# 变量

## var

​	在函数里省略变量的声明，会创建一个全局的var，变量提升会将所有的var声明拉到作用域的顶部（局部作用域，全局作用域），var重复声明的变量会被合并为一个。

### var 与function

​	在javascript中，var、function会变量提升（hoisting）；var声明，会在任何code执行前，将变量提升到所在作用域的最高处。function声明，在编译阶段加载到内存，所以在var声明之前就会执行。

## let

​	let与var的区别：它不会被提升，其作用域是一对{}的块级作用域。let不能重复声明同一个变量。**“暂时性死区”指的是，在let声明变量前调用该变量**。 在for循环中，自变量用let定义，每次循环时都声明一个新的迭代变量。

```javascript
var a = [];
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
```

​	此处a[6]函数调用function时内部的i由于是var定义的，经过循环后已经变为10，所以输出10；使用let i;则输出6；

## const

定义为常量不能修改，作用域与let一样为块级作用域，const定义的对象不能在赋值为其他引用值，但对象的键值不受限制。

```javascript
const o1={};
o1={}//typeerror：给
const o2={};
o2.name='jake';//可以
```



总结：var 声明的变量存在变量提升，let & const 声明的变量，在声明之前使用会报错，而 const 声明必须在声明的同时为其赋值；

## 变量类型

- 原始类型

  - Undefined  未被定义的变量

  - Null              空对象指针，typeof返回的是object

  - Boolean       true false

  - Number       特殊值NaN不是数值

  - String

  - Symbol

    按值访问， 可操作保存在变量中的实际值， 保存在栈内存中。

- 引用类型

  - Date
  - RegExp
  - 原始值包装类型 Boolean
  - 原始值包装类型Number
  - 原始值包装类型 String
  - Array

 按引用访问， 不可直接操作访问对象内存空间， 保存在栈内存和堆内存中。

## 变量复制

基本类型：

创建新值，把该值复制到新分配的变量地址上，两值可参与任何操作而不互相影响。

引用类型：

创建一个新的指针（指针指向存储堆里被复制的对象），将该指针放到为新变量分配的栈空间里

## 参数传递

ECMAScrpit中的所有参数都是**按值传递**的。基本类型和引用类型作参数传递都类似于复制。

- **基本类型**：被传递的值会被复制给函数的内的局部变量，函数内部的局部变量**不会影响**函数外部的变量的值。
- **引用类型**：将内存中的地址的值（指向堆内数据）复制给函数内部的局部变量（这时局部变量和函数外的变量都指向同一个堆内数据），局部作用域修改的值**会在全局反映**。

## 类型检查

typeof

当需要变量是否是number, string, boolean,  function类型时，可以使用typeof进行判断。其他变量是判断不出类型的，包括null。

| typeof undefined       | 'undefined' |
| ---------------------- | ----------- |
| typeof null            | 'object'    |
| typeof true            | 'boolean'   |
| typeof 123             | 'number'    |
| typeof "abc"           | 'string'    |
| typeof function() {}   | 'function'  |
| typeof {}              | 'object'    |
| typeof []              | 'object'    |
| typeof unknownVariable | 'undefined' |

instanceof:判断参照对象的prototype属性所指向的对象是否在被行测对象的原型链上。其语法是`object instanceof constructor`.可以用来判断引用类型

constructor：调用对象上的constructor属性，指向构造函数。可以检测出除了undefined和null的9种类型

Object.prototype.toString.call：可以取得对象的内部属性[[class]],并根据这个内部属性返回诸如"[object  Number]"的字符串.那么我们就可以通过call获取内部属性[[class]]

# 作用域

js代码在编译阶段会确定作用域，再执行阶段会创建作用域链。

作用域是一套规则，用于确定在何处以及如何查找变量（标识符），也就是说这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找；作用域规则是在代码的编译阶段确定的。

负责收集并维护由所有声明的标识符（变量）组成的一系列查询，并实施一套非常严格的规则，确定当前执行的代码对这些标识符的访问权限。

### 作用域链

作用域链本质上是一个指向当前环境与上层环境的一系列**变量对象**的指针列表（它只引用但不实际包含变量对象），作用域链保证了当前执行环境对符合访问权限的变量和函数的有序访问。

# 原型

- .prototype

  只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个prototype属性（同时它也是一个对象），默认情况下prototype属性(对象)会默认获得一个constructor(构造函数)属性，这个属性是一个指向prototype属性所在的函数。**prototype(对象属性)的所有属性和方法，都会被构造函数的实例继承。**这意味着，我们可以把那些不变(公用)的属性和方法，直接定义在prototype对象属性上。

- _proto_

  每一个实例对象都有一个私有属性**__proto__**,指向它的构造函数的原型对象(**prototype**)。原型对象也有自己的**__proto__**，层层向上直到一个对象的原型对象为`null`。这一层层原型就是原型链。prototype就是调用构造函数所创建的那个实例对象的原型（**proto**）。

   
  
  ```js
  function Foo() {
              getName = function() { //定义成this.getname则是 Foo的方法
                  alert(1);
              }
          }
          Foo.prototype.getName = function(){
              alert(2)
          }
          Foo.getName = function(){
              alert(3)
          }
  
  ```
  
  此时如果直接运行Foo.getName();方法的话，输出3的。而如果new一个Foo的实例，再执行getName()方法的话，就会输出2。而Foo上的getName实际上是一个未经过声明的全局变量，在全局范围内直接执行getName()就可以输出1。
  
  ```js
   var a = new Foo;
          a.getName();    // 2
   
          Foo.getName();  // 3
   
          getName();      // 1
  ```
  
  

## 原型链 （JS原型与原型链继承）

实例对象与原型之间的连接，叫做原型链。**proto**( 隐式连接 )
 JS在创建对象的时候，都有一个叫做**proto**的内置属性，用于指向创建它的函数对象的原型对象prototype。
 内部原型(**proto**)和构造器的原型（prototype）
 1、每个对象都有一个**proto**属性,原型链上的对象正是依靠这个属性连结在一起
 2、作为一个对象，当你访问其中的一个属性或方法的时候，如果这个对象中没有这个  方法或属性，那么Javascript引擎将会访问这个对象的**proto**属性所指向上一个对 象，并在那个对象中查找指定的方法或属性，如果不能找到，那就会继续通过那个对象  的**proto**属性指向的对象进行向上查找，直到这个链表结束。

# this

​	this 在标准函数和胖箭头函数中的行为**不同**。

​	在标准函数中，this指向把函数当作方法调用该函数的上下文对象。也就是说函数里的this指向是不确定的且在函数执行过程中会改变，**取决于调用包含这个this的函数的上下文对象（作用域对象**）

​	在胖箭头函数中，this指向定义包含this的函数的上下文，他是**不变的**。

## this的四种绑定规则

默认绑定：

this没有绑定指向时，默认绑定window。

隐式绑定：

隐式绑定规则会把函数调用中的 this 绑定到这个上下文对象。

显式绑定：

使用 apply call bind 进行强制绑定。

new绑定：

使用 new 来调用函数，或者说发生构造函数调用时，会自动执行下面的操作。

### this绑定优先级：

new绑定>显式绑定>隐式绑定>默认绑定



默认绑定和隐式绑定举例：

```js
<script>
       var name='小红'
        function a() {
            var name = '小白';
                console.log(this.name);
        }
        function d(i){
            return i();
        }
        var b={
            name:'小黄',
            detail:function(){
                console.log(this.name);
            },
            bibi:function(){
                return function(){
                    console.log(this.name)
                };
            }
        }
        var c=b.detail;
        b.a=a;
        var e=b.bibi();
//注意：b.bibi()返回的是函数 f() : console.log(this.name);而b.bibi返回的是f():  return function(){ console.log(this.name)}
        a(); //全局调用 this指向window 
        c();//b.detail调用的时候this指向b对象，但是这里将b的方法赋值给c，最终还是c在全局下调用，因此this指向window
        b.a();//b.a()是给b对象新添加的方法，用function a（）赋值。由于是对象b的方法，因此this指向b
        d(b.detail);//最终的调用者是d() this指向window
        e();//最终的调用者是e() this指向window 
    </script>
```

### 出现函数嵌套的this指向问题：

如果是普通的函数嵌套，this指向window

如果对象中的方法中嵌套的方法，只有对象的第一层方法的this指向该对象，其余嵌套函数this指向window，；想要访问对象的this可以试用箭头函数或者call bind apply绑定

### call apply bind 可以改变this指向

call和apply的第一个参数是需要改变的this的对象；第二个参数有不同。apply的第二个参数是arguements参数数组，起到传参的作用，而call没有arguements,只能一个个传递参数；

bind和call功能一样，但是bind返回的是一个函数。call和apply是直接执行的函数，bind可以稍后执行

### setTimeout与this

setTimeout中所执行函数中的this，永远指向window！！注意是要延迟执行的函数中的this

setTimeout(this.method, time)这种形式中的this，即第一个this，是根据上下文来判断的，默认为全局作用域

# 尾调用优化

https://segmentfault.com/a/1190000014747296

​	斐波那契数列如果用普通的递归的写法，时间复杂度O（2的n次幂）,栈调用次数也是。每次递归调用都会呈指数往调用栈里增加记录“调用帧“，这样做，当项比较多，就会出现“栈溢出”的。

```javascript
function f(n) {
    if(n === 0) return 0;
    if(n === 1) return 1;
    return f(n - 1) + f(n -2);
}
```

​	函数调用会在内存形成一个“调用记录”，又称“调用帧”，保存调用位置和内存变量等信息。如果在函数`A`的内部调用函数`B`，那么在`A`的调用帧上方，还会形成一个`B`的调用帧。等到`B`运行结束，将结果返回到`A`，`B`的调用帧才会消失。如果函数`B`内部还调用函数`C`，那就还有一个`C`的调用帧，依次类推。所有的调用帧，就形成一个“调用栈”。函数嵌套一次就会有一个栈帧加载到栈上。**满足尾调用优化的条件后，外层函数执行完后栈帧就会被推出**，在加载内层函数的栈帧，这样始终只有一个栈桢。

```javascript
//重构函数，满足尾调优化的条件
function fib(n){
    return careat_fib(0,1,n);
}
function careat_fib(pre,next,n)
{
    if(n==0)
        return pre;
    else
        return function(next,pre+next,n-1);
}
```

也可以用迭代的方式实现斐波那契，减少栈的消耗。

# 期约

1、Promise，他是一个对象，是用来处理异步操作的。

2、Promise有三种状态：pending（进行中），resolved（完成），rejected（失败）。

3、`Promise`构造函数接受一个函数作为参数，该函数的两个参数分别是`resolve`和`reject`。它们是两个函数，由 JavaScript 引擎提供，不用自己部署。由他们改变期约的状态。

4、`Promise`实例生成以后，可以用`then`方法分别指定`resolved`状态和`rejected`状态的回调函数。若只指定一个回调函数默认是resolved（）回调函数。resolved（）回调函数接受（value）参数；rejected（）回调函数接受（reason）参数

## 期约连锁

解决地狱回调问题，每一个后续处理的程序都必须等待前一个期约解决，然后实例化一个新的期约并返回它。

## promise.all()

创建一组合成期约，当每个期约都成功解决后才返回成功，合成期约的解决值是有每一个期约的解决值组成的数组；如果有一个期约拒绝，则合成期约返回第一个拒绝期约的reason。

```js
let p=Promise.all([
	Promise.resolve(),
	new Promise((resolve,reject=>{resolve();}),
	Promis.reject();
])
```

# 函数柯里化

​	柯里化是把接受**多个参数**的函数变换成接受一个单一参数的函数，并且返回接受余下参数的新函数的技术。当有一部分参数是通常不变，一部分参数改变时可以应用柯里化

它既能减少代码冗余，也能增加可读性。

```js
// 实现一个add方法，使计算结果能够满足如下预期：
add(1)(2)(3) = 6;
add(1, 2, 3)(4) = 10;
add(1)(2)(3)(4)(5) = 15;

function add() {
    // 第一次执行时，定义一个数组专门用来存储所有的参数
    var _args = Array.prototype.slice.call(arguments);

    // 在内部声明一个函数，利用闭包的特性保存_args并收集所有的参数值
    var _adder = function() {
        _args.push(...arguments);
        return _adder;
    };

    // 利用toString隐式转换的特性，当最后执行时隐式转换，并计算最终的值返回
    _adder.toString = function () {
        return _args.reduce(function (a, b) {
            return a + b;
        });
    }
    return _adder;
}

add(1)(2)(3)                // 6
add(1, 2, 3)(4)             // 10
add(1)(2)(3)(4)(5)          // 15
add(2, 6)(1)                // 9
```

# 继承

https://www.cnblogs.com/humin/p/4556820.html

https://geyao.blog.csdn.net/article/details/108456180

## 原型链继承

将父类的实例作为子类的原型

特点：

1. 非常纯粹的继承关系，**实例是子类的实例，也是父类的实例**
2. 父类新增原型方法/原型属性，子类都能访问到
3. 简单，易于实现

缺点：

1. 要想为子类新增属性和方法，必须要在`new Animal()`这样的语句之后执行，不能放到构造器中
2. **无法实现多继承**（一个子类继承多个父类的属性和方法）
3. 来自原型对象的所有**属性被所有实例共享**（来自原型对象的引用属性（数组，对象）是所有实例共享的，子类的一个实例修改后，其他的实例的属性也会修改）
4. 创建子类实例时，无法向父类构造函数传参

## 构造函数继承（call）

**核心：**使用父类的构造函数来增强子类实例，等于是复制父类的实例属性给子类（没用到原型）

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
```

特点：

1. **解决了1中，子类实例共享父类引用属性的问题**
2. 创建子类实例时，可以向父类传递参数
3. 可以实现多继承（call多个父类对象）

缺点：

1. **实例并不是父类的实例，只是子类的实例**,子类相当于复制了父类的属性方法
2. 只能继承父类的实例属性和方法，不能继承原型属性/方法
3. 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能

# 组合继承

将原型链和借用构造函数的技术组合到一块。使用原型链实现对原型属性和方法的继承，而通过构造函数来实现对实例属性的继承。

```js
function Cat(name){
  Animal.call(this);
  this.name = name || 'Tom';
}
Cat.prototype = new Animal();
```



###### 特点：

1. 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
2. 既是子类的实例，也是父类的实例
3. 不存在引用属性共享问题
4. 可传参
5. 函数可复用

###### 缺点：

调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）

## 寄生式继承

## 寄生式组合继承

通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法/属性，避免的组合继承的缺点。使用寄生式继承，继承父类的原型，然后将返回的新对象赋值给子类原型。

## 拷贝继承

拷贝父类实例的所有属性方法给 子类的原型

```js
function Cat(name){
  var animal = new Animal();
  for(var p in animal){
    Cat.prototype[p] = animal[p];
  }
```

缺点

占用内存空间

# 数组去重

1、函数里声明一个空数组，循环调用数组，空数组里如果不能找到循环数组的数据，则向这个空数组里面添加该数据，最后返回这个新数组。

```js
if (newarr.indexOf(arr[i]))
newarr.push(arr[i]);
```

2、首先排序，排序后重复的数据会在相邻位置，用arr的第i个和空数组的最后一位做比较，如果不相等则添加到空数组中。最后返回这个数组，这么做的缺点是最后的返回值也是排序后的，如果需要和原数组同样位置的数据则不适用。

```
arr.sort();
for(let i=0;i<arr.length;i++)
{
	if(arr[i]!==newarr[newarr.length-1])
		newarr.push(arr[i]);
}
```

# 深浅拷贝

简单数据类型没有深浅拷贝之说；

浅拷贝：object.assign(), ...展开运算符，array.prototype.concat（）,array.prototype.slice()

复制对象的所有属性值，如果是基本数据类型，则会有新的独立空间存储值；但如果是引用类型，则复制的是引用，存储的也是引用，引用数据的值并没有复制过来。修改拷贝对象中引用数据类型的属性，元对象的引用数据类型的值也会改变。

深拷贝： json.stringfy(json.parse)、递归

深拷贝会创建一个完全一样的对象，且不会共享堆内存。会将属性和属性下的属性都复制一份

浅拷贝 : 只拷贝一层,更深层次对象级别的只能拷贝引用
深拷贝: 拷贝多层,每一级别的数据都会拷贝

# 闭包

闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。

1、闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，我们可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。

2、函数的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。

其实闭包的本质就是作用域链的一个特殊的应用，只要了解了作用域链的创建过程，就能够理解闭包的实现原理。

# 事件处理机制

**执行栈（主线程中）**：js是单线程的，当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境（执行上下文），然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。这个过程反复进行，直到执行栈中的代码全部执行完毕。

**异步事件：**js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。

**任务队列：**当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为任务队列。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去（微任务队列 ->事件队列（宏任务队列））查找是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码。

1. JS是单线程的，同一时间只能执行一件事，但是像ajax、setTimeOut等事件需要过一段时间后再执行它的回调函数，如果主线程一直等待就会浪费很多cpu资源。所以当我们在执行Script主体代码的时候，如果遇到这类异步事件就将他们先放到任务队列里去，将setTimeOut、setInterval等宏任务放到宏任务队列，将Promise这种任务放入微任务队列，然后继续执行Script主体代码，将代码逐个压入主线程的执行栈中执行，如果遇到新的执行环境比如一个函数，就把相应执行环境也压入执行栈中，执行完了后再出栈。

2. 当执行栈为空时，即Script主体代码执行完毕，js引擎会先去检查微任务队列，如果不为空，则依次将微任务队列中的任务加入到执行栈中执行；如果微任务队列为空了，则将宏任务队列的中的任务逐个加入到执行栈中执行。执行完后再检查微任务队列是否为空，如此往复，就是**事件循环机制**。（注意：script（整体代码）作为一个宏任务，一旦全部执行完毕就会去执行其后的微任务。）

宏任务：**包括整体代码script，setInterval，setImmediate，setTimeout**。

微任务：原生**Promise(有些实现的promise将then方法放到了宏任务中)、process.nextTick、MutationObserve**

两者属于一个队列，主要区别在于它们的执行顺序（宏任务执行完如果有可执行的微任务则执行完微任务才会继续执行下一个宏任务）

**宏任务和微任务的区别**

宏队列可以有多个，微任务队列只有一个,所以每创建一个新的settimeout都是一个新的宏任务队列，执行完一个宏任务队列后，都会去checkpoint 微任务。

一个事件循环后，微任务队列执行完了，再执行宏任务队列

一个事件循环中，在执行完一个宏队列之后，就会去check 微任务队列

运行机制：在事件循环中，每进行一次循环操作称为 tick，每一次 tick 的任务处理模型是比较复杂的，但关键步骤如下：

\1. 执行一个宏任务（栈中没有就从事件队列中获取）

\2. 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中

\3. 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）

\4. 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染

\5. 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）
