[TOC]



# 浏览器输入url（uniform resource locator）

经历的过程：

1. URL 解析：

   首先判断你输入的是一个合法的 URL，解析出协议，网址，资源路径等信息，

2. DNS 查询：

   浏览器缓存->系统缓存（host）->路由器缓存->DNS缓存 ->DNS服务器查询

   dns服务器有：根服务器，顶级服务器，权威服务器

   DNS服务器查询方式：递归方式；迭代方式

3. TCP 连接：

   客户端与服务器简历连接，TCP是因特网中的传输层协议，使用三次握手协议建立连接。当主动方发出SYN连接请求后，等待对方回答SYN+ACK，并最终对对方的 SYN 执行 ACK 确认。

4. 发送http请求：

   浏览器根据解析到的IP地址和端口号发起http的get请求

5. 处理请求

   服务器根据浏览器发送的请求返回数据和资源

6. 渲染页面

   接受到服务端的资源并渲染到页面上

# 浏览器渲染页面

1、HTML解析，节点，生成dom树，过程是一个深度优先遍历。即先构建当前节点的所有子节点，再构建下一个兄弟节点。若遇到 script 标签，则 DOM 树的构建会暂停，直至脚本执行完毕。

2、解析css，生成css规则树，遇到js代码会则暂停执行js，直至css规则树构建完再执行。css规则树需要等到完全构建后才可以被使用，因为后面的属性可能会覆盖掉前面的设置。CSS被视为阻塞渲染的资源，应放到代码的头部尽快加载。

3、根据dom和css规则树，构造生成render树。

4、根据render树计算每一个节点的信息，位置和尺寸

5、根据计算的信息渲染页面：

- 重绘：某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的重绘。
- 回流（重排）：某个元素的尺寸发生了变化，则需重新计算渲染树，重新渲染。

# 网站性能优化

# https

对称加密：客户端服务端使用密文加密数据，但是**密钥只有一个**，容易被黑客获得并窃取数据

非对称加密：服务端存有公钥（pk）和私钥(sk)，客户端获取服务端公钥，在将数据用公钥加密非给服务端，服务端用私钥解密数据。问题是，**服务端没法将数据返回给客户端**，如果用公钥加密返回，客户端没有私钥，不能解密；如果用私钥加密，容易给黑客截取。

对称加密+非对称加密：客户端随机生成的一个字符串，先使用非对称加密，确定出该客户端与服务端交换数据的密钥，这是唯一的。在通过对称加密，交换数据。但是任然存在**中间人问题**

针对中间人问题：引入CA机构认证的公钥

过程：CA机构也有公钥（cpk）和私钥(csk)；用ca机构的私钥（csk）加密服务器的公钥（pk）得到一个证书license，客户端请求这个license,再用已经存在客户端的ca机构的公钥（cpk）解密license获得服务器的公钥（pk）。接着就是对称加密，获得客户端与服务端的k

# xss跨站脚本攻击

恶意攻击者在web页面中会插入一些恶意的script代码。当用户浏览该页面的时候，那么嵌入到web页面中script代码会执行，因此会达到恶意攻击用户的目的。

## 分类：

DOM型攻击:

​	客户端的js可以对页面dom节点进行动态的操作，比如插入、修改页面的内容。比如说客户端从URL中提取数据并且在本地执行、如果用户在客户端**输入的数据包含了恶意的js脚本**的话，但是这些脚本又没有做任何过滤处理的话，那么我们的应用程序就有可能受到DOM-based XSS的攻击。

反射型攻击：

​	在url后面的参数中加上恶意代码，当用户点击链接访问时，网站的服务端将恶意代码从url中提取出，并拼接到html里返回给浏览器端，浏览器解析html时就会执行恶意代码

存储型攻击：

攻击者将恶意代码提交到网站的数据库中，用户打开网站，服务器将恶意代码从数据库中取出，并拼接到html中返回给浏览器端

# SQL注入

​	是通过客户端的输入把SQL命令注入到一个应用的数据库中，从而执行恶意的SQL语句。sql语句伪造参数，然后对参数进行拼接后形成xss攻击的sql语句。最后会导致数据库被攻击了。

防范的方法：
1. 我们可以使用预编译语句(PreparedStatement，这样的话即使我们使用sql语句伪造成参数，到了服务端的时候，这个伪造sql语句的参数也只是简单的字符，并不能起到攻击的作用。
2. 数据库中密码不应明文存储的，可以对密码使用md5进行加密，为了加大破解成本，所以可以采用加盐的方式.



# CSRF跨站点请求伪造

csrf：跨站点请求伪造（Cross-Site Request Forgeries），也被称为 one-click attack 或者 session riding。冒充用户发起请求（在用户不知情的情况下）， 完成一些违背用户意愿的事情（如修改用户信息，删初评论等）。

![img](https://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg)

# 网络安全策略

## 设置cookie：

**http-only**: 只允许http或https请求读取cookie、JS代码是无法读取cookie的(document.cookie会显示http-only的cookie项被自动过滤掉)。发送请求时自动发送cookie.
**secure-only:** 只允许https请求读取，发送请求时自动发送cookie。
**host-only:** 只允许主机域名与domain设置完成一致的网站才能访问该cookie。

## 设置**X-XSS-Protection**

响应头中设置是用来防范XSS攻击的。它有如下几种配置：
值有如下几种：默认为1.
0：禁用XSS保护。
1：启用XSS保护。
1;mode=block; 启用xss保护，并且在检查到XSS攻击是，停止渲染页面。

## 加强编码

HTML编码：

​	将 & < > " ' / 转义为实体字符

html属性编码

​	编码规则：除了字母、数字、字符以外，使用 &#x;16进制格式来转义ASCII值小于256所有的字符。

url编码：

将不可信数据作为 URL 参数值时需要对参数进行 URL 编码

​	将参数值进行 encodeURIComponent 编码

css编码：

作用范围：将不可信数据作为 CSS 时进行 CSS 编码

编码规则：除了字母数字字符以外，使用\XXXXXX格式来转义ASCII值小于256的所有字符

## 开启csp网络安全政策

​	CSP是网页安全政策(Content Security Policy)的缩写。主要用来防止XSS攻击。是一种由开发者定义的安全性政策申明，通过CSP所约束的责任指定可信的内容来源，通过 Content-Security-Policy 网页的开发者可以控制整个页面中 外部资源 的加载和执行。
​	比如可以控制哪些 域名下的静态资源可以被页面加载，哪些不能被加载。这样就可以很大程度的防范了 来自 跨站(域名不同) 的脚本攻击。

# http请求

## 三次握手四次挥手

- 第一次：客户端发送请求到服务器，服务器知道客户端发送，自己接收正常。SYN=1,seq=x
- 第二次：服务器发给客户端，客户端知道自己发送、接收正常，服务器接收、发送正常。ACK=1,ack=x+1,SYN=1,seq=y
- 第三次：客户端发给服务器：服务器知道客户端发送，接收正常，自己接收，发送也正常.seq=x+1,ACK=1,ack=y+1

上面分析过程可以看出，握手两次达不到让双方都得出自己、对方的接收、发送能力都正常的结论的。

## 五个方法

- GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
- POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
- PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
- HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
- DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
- OPTIONS：查询相应URI支持的HTTP方法。

## GET方法与POST方法的区别

1、

​	get重点在从服务器上获取资源，post重点在向服务器发送数据；
2、

​	get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如http://127.0.0.1/Test/login.action?name=admin&password=admin，这个过程用户是可见的；
​	post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；

服务端在处理get请求时，数据从

3、
	Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式；
4、

​	get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；
post较get安全性较高；
5、
​	get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码。post支持标准字符集，可以正确传递中文字符。

## HTTP请求报文与响应报文格式

请求报文包含三部分：
a、请求行：包含请求方法、URI、HTTP版本信息
b、请求首部字段
c、请求内容实体
响应报文包含三部分：
a、状态行：包含HTTP版本、状态码、状态码的原因短语
b、响应首部字段
c、响应内容实体

## 常见的HTTP相应状态码

200：请求被正常处理
204：请求被受理但没有资源可以返回
206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
301：永久性重定向
302：临时重定向
303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
304：发送附带条件的请求时，条件不满足时返回，与重定向无关
307：临时重定向，与302类似，只是强制要求使用POST方法
400：请求报文语法有误，服务器无法识别
401：请求需要认证
403：请求的对应资源禁止被访问
404：服务器无法找到对应资源
500：服务器内部错误
503：服务器正忙

## http报文格式：

请求报文包含三部分：
a、请求行：包含请求方法、URI、HTTP版本信息
b、请求首部字段（请求头）cors跨域需要的请求头：orgin
c、请求内容实体
响应报文包含三部分：
a、状态行：包含HTTP版本、状态码、状态码的原因短语
b、响应首部字段（响应头）cors跨域需要的响应头：Access-Control-Allow-Origin
c、响应内容实体

# HTTP1.0,HTTP1.1,HTTP2.0

**HTTP 1.0**:规定浏览器与服务器只保持短暂的连接，浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接，服务器不跟踪每个客户也不记录过去的请求。

**HTTP 1.1**支持**持久连接**（HTTP/1.1的默认模式使用带流水线的持久连接），在一个TCP连接上可以传送多个HTTP请求和响应，减少了建立和关闭连接的消耗和延迟。在http1.1，request和reponse头中都有可能出现一个connection的头，默认使用Connection: keep-alive。HTTP 1.1中**增加Host请求头**字段后，WEB浏览器可以使用主机头名来明确表示要访问服务器上的哪个WEB站点，这才实现了在一台WEB服务器上可以在同一个IP地址和端口号上使用不同的主机名来创建多个虚拟WEB站点。HTTP1.1则引入了更多的**缓存控制策略**例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。	HTTP1.1在请求头中引入range头域，它允许只请求资源的某个部分，这样就方便了开发者自由的选择以便于**充分利用带宽和连接**。

**HTTP2.0**

**多路复用 (Multiplexing)**

​	多路复用允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。在 HTTP/1.1 协议中浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞。这也是为何一些站点会有多个静态资源 CDN 域名的原因之一，拿 Twitter 为例，http://twimg.com，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。而 HTTP/2 的多路复用(Multiplexing) 则允许同时通过单一的 HTTP/2 连接发起多重的请求-响应消息。因此 HTTP/2 可以很容易的去实现多流并行而不用依赖建立多个 TCP 连接，HTTP/2 把 HTTP 协议通信的基本单位缩小为一个一个的帧，这些帧对应着逻辑流中的消息。并行地在同一个 TCP 连接上双向交换消息。

**二进制分帧**

​	HTTP/2在 应用层(HTTP/2)和传输层(TCP or UDP)之间增加一个二进制分帧层。在不改动 HTTP/1.x 的语义、方法、状态码、URI 以及首部字段的情况下, 解决了HTTP1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。

**首部压缩（Header Compression）**

​	在HTTP1.0/1.1中，头部元数据都是以纯文本的形式发送的，通常会给每个请求增加500~800字节的负荷。

​	HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。高效的压缩算法可以很大的压缩header，减少发送包的数量从而降低延迟。

**服务端推送（Server Push）**

服务器除了对最初请求的响应外，服务器还可以额外的向客户端推送资源，而无需客户端明确的请求

# 跨域

浏览器的同源策略限制了跨源数据的访问。同源：协议，端口，域名相同

实现跨域的方式：

1.JSONP(JSON with padding)原理：
 	利用html里面script标签可以加载其他域下的js这一特性，使用script src的形式来获取其他域下的数据，但是因为是通过标签引入的，所以会将请求到的JSON格式的数据作为js去运行处理，显然这样运行是不行的，所以就需要提前将返回的数据包装一下，封装成函数进行运行处理，函数名通过接口传参的方式传给后台，后台解析到函数名后在原始数据上「包裹」这个函数名，发送给前端。（JSONP 需要对应接口的后端的配合才能实现）只支持get请求

2 CORS 跨域资源共享（Cross-Origin Resource Sharing） 官方的解决跨域的方案

​	特点：不需要在客户端做任何操作，完全在服务器中处理，实现跨域。支持get，post等其他请求。当使用 XMLHttpRequest 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个HTTP请求头：Origin。后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin，值为相同的源，或者”*“。

jsonp：

客户端：

```javascript
<script>
       function handlefunction(data){
            var result=document.getElementById('result');
            result.innerHTML=data.name;
       } 
    </script>
    <!--jsonp 的实现：
        利用script的跨域特性，传输的数据必须包含在服务端响应的返回函数中，
        因为只有函数或者代码才能被script标签解析，
        这里设置了回调函数为handlefunction，传递的参数是一个对象，
        在页面内定义的回调函数内可以执行操作-->
    <script src='http://localhost:9000/jsonp'></script>
```

服务端：

```javascript
app.all('/jsonp',(request,response)=>{
    var data={
        name:'cuizhufan'
    }
    var str=JSON.stringify(data);
    response.end(`handlefunction(${str})`);
});
```

3 代理转发

​	跨域是为了突破浏览器的同源策略限制，既然同源策略只存在于浏览器，那可以换个思路，在服务端进行跨域，比如设置代理转发。这种在服务端设置的代理称为“反向代理”，在当前被访问的服务器配置一个请求转发规则。

vite中反向代理

```js
  server:{
    host:'localhost',
    port:8080,
    proxy:{
      "/api":{
        target:"http://localhost:3000"
      }
    }
  },
```

# 前端缓存

缓存策略可以缩短网页请求资源的距离，减少延迟，并且由于缓存文件可以重复利用，还可以减少带宽，降低网络负荷。分为HTTP缓存，在HTTP请求传输时用到；浏览器缓存，前端开发时存储数据。

## HTTP缓存

https://blog.csdn.net/m0_37747665/article/details/83045494

### 强缓存

强制缓存的含义是，当客户端请求后，会先访问缓存数据库看缓存是否存在且未过期。如果存在则直接返回；不存在则请求真的服务器，响应后再写入缓存数据库。与强缓存主要相关的响应报文首部字段有expires和cache-control。

1、**expires**，这是http1.0时的规范；它的值为一个**绝对时间**的GMT格式的时间字符串，，如果发送请求的时间在expires之前，那么本地缓存始终有效，否则就会发送请求到服务器来获取资源
2、**cache-control**：max-age=number，这是http1.1时出现的header信息，主要是利用该字段的max-age值来进行判断，它是一个**相对值**；资源第一次的请求时间和Cache-Control设定的有效期，计算出一个资源过期时间，再拿这个过期时间跟当前的请求时间比较。；

### 协商缓存

协商缓存都是由服务器来确定缓存资源是否可用的，所以客户端与服务器端要通过某种标识来进行通信，从而让服务器判断请求资源是否可以缓存访问，这主要涉及到下面两组header字段，这两组搭档都是**成对**出现的，即第一次请求的响应头带上某个字段（Last-Modified或者Etag），则后续请求则会带上对应的请求字段（If-Modified-Since或者If-None-Match），若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段。

**1、Last-Modified/If-Modified-Since**
二者的值都是GMT格式的时间字符串，具体过程：
（1）浏览器第一次跟服务器请求一个资源，服务器在返回这个资源的同时，在响应头加上Last-Modified，表示这个资源在服务器上的最后修改时间；
（2）浏览器再次跟服务器请求这个资源时，在请求头上加上If-Modified-Since，就是上一次请求时返回的Last-Modified的值；
（3）服务器再次收到资源请求时，根据浏览器传过来If-Modified-Since和资源在服务器上的最后修改时间判断资源是否有变化，如果没有变化则返回304 Not Modified，但是不会返回资源内容；如果有变化，就正常返回200和资源内容。当服务器返回304 Not Modified的响应时，响应头中不会再添加Last-Modified的header。
（4）浏览器收到304的响应后，就会从缓存中加载资源；
（5）如果协商缓存没有命中，浏览器直接从服务器加载资源时，Last-Modified的Header在重新加载的时候会被更新，下次请求时，If-Modified-Since会启用上次返回的Last-Modified值。
**2、Etag/If-None-Match**
这两个值是由服务器生成的每个资源的唯一标识字符串，当资源有变化时，这个值就会改变；其判断过程与Last-Modified/If-Modified-Since类似，与Last-Modified不一样的是，当服务器返回304 Not Modified的响应时，由于ETag重新生成过，response header中还会把这个ETag返回，即使这个ETag跟之前的没有变化。

Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

### 总结

1. 调用 Service Worker 的 `fetch` 事件响应

2. 查看 memory cache

3. 查看 disk cache。这里又细分：

4. 1. 如果有强制缓存且未失效，则使用强制缓存，不请求服务器。这时的状态码全部是 200
   2. 如果有强制缓存但已失效，使用对比缓存，比较后生效返回304 ；失败返回200 和请求的资源



1. 发送网络请求，等待网络响应
2. 把响应内容存入 disk cache (如果 HTTP 头信息配置可以存的话)
3. 把响应内容 **的引用** 存入 memory cache (无视 HTTP 头信息的配置)
4. 把响应内容存入 Service Worker 的 Cache Storage (如果 Service Worker 的脚本调用了 `cache.put()`)

## 浏览器缓存

### localStorage

是HTML5的一种本地缓存方案

### sessionStorage

和localStorage的功能类似，但是sessionStorage在浏览器关闭时会自动清空

### Cookie

（或Cookies），指网站为了辨别用户身份或Session跟踪而储存在用户浏览器端的数据。cookie信息一般会通过HTTP清求发送到服务器端。

# 前端性能优化

1、使用缓存（最重要的一点），cookie与WebStorage
2、减少http请求
3、文件压缩合并：html，js，css压缩。删除一些无用代码：注释
4、图片无损压缩，安卓下可以使用webp格式图片
5、使用字体图标，矢量图svg，雪碧图，base64
6、js文件一般放在页面底部，若放在head里一般要在script标签上加 async 或者 defer 进行异步加载
7、懒加载，预加载
8、减少dom操作，规避重绘与回流；更改css属性较多时，以类名的形式操作dom；有复杂动画的DOM，可以考虑使其脱离文档流，从而减少重绘与回流的范围
9、事件的节流与防抖
10、事件委托。利用事件冒泡，通过指定一个事件处理程序，来管理某一类型的所有事件。这样能减少页面消耗的内存
11、启用DNS预解析。遇到网页中的超链接，DNS prefetching从中提取域名并将其解析为IP地址，这些工作在用户浏览网页时，使用最少的CPU和网络在后台进行解析
12、减少不必要的 DOM 节点，DOM 树的深度越浅，浏览器解析越快

